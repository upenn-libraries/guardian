#!/usr/bin/env ruby

require 'active_record'
require 'find'
require 'logger'
require 'stronghold'
require 'todo_runner'
require 'yaml'
require 'zip'
require 'rsync'
require 'shellwords'

require_relative('lib/secrets_manager')
require_relative('lib/chunk_sizer')
require_relative('lib/manifest_validation')

##
# Monkey patching Rsync::Result to get useful error messages.
class Rsync::Result
  def raw
    @raw
  end

  def full_error
    return if self.success?
    raw.split($/).grep(/^rsync( error)?:/).join $/
  end
end

# Copied from https://github.com/rubyzip/rubyzip

class ZipFileGenerator
  def initialize(input_dir, output_file)
    @input_dir = input_dir
    @output_file = output_file
  end

  def write
    entries = Dir.entries(@input_dir) - %w(. ..)
    ::Zip::File.open(@output_file, ::Zip::File::CREATE) do |zipfile|
      write_entries entries, '', zipfile
    end
  end

  private

  def write_entries(entries, path, zipfile)
    entries.each do |e|
      zipfile_path = path == '' ? e : File.join(path, e)
      disk_file_path = File.join(@input_dir, zipfile_path)
      puts "Deflating #{disk_file_path}"

      if File.directory? disk_file_path
        recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
      else
        put_into_archive(disk_file_path, zipfile, zipfile_path)
      end
    end
  end

  def recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
    zipfile.mkdir zipfile_path
    subdir = Dir.entries(disk_file_path) - %w(. ..)
    write_entries subdir, zipfile_path, zipfile
  end

  def put_into_archive(disk_file_path, zipfile, zipfile_path)
    zipfile.get_output_stream(zipfile_path) do |f|
      f.write(File.open(disk_file_path, 'rb').read)
    end
  end

end

class GlacierArchive < ActiveRecord::Base
  has_many :table_relationship
end

LOGGER = Logger.new(STDOUT)
LOGGER.level = Logger::INFO

TodoRunner.define do

  MANIFEST_MAP = {
    'manifest-sha1.txt'   => 'sha1',
    'manifest-sha256.txt' => 'sha256',
    'manifest-sha384.txt' => 'sha384',
    'manifest-sha512.txt' => 'sha512',
    'manifest-md5.txt'    => 'md5'
  }.freeze

  def fetch_source(source, workspace, application, method)
    case "#{application}_#{method}"
      when 'bulwark_gitannex'
        bg_secrets = SecretsManager.load_secrets('secrets/bulwark_gitannex.secret')
        SecretsManager.set(bg_secrets)
        `git clone #{source} #{workspace}/#{File.basename(source)}`
        Dir.chdir("#{workspace}/#{File.basename(source)}") do
          `./.repoadmin/bin/init.sh`
          `git annex get .`
          `git annex unlock .`
        end
        SecretsManager.unset(bg_secrets)
        return "#{workspace}/#{File.basename(source)}"
      when 'openn_rsync'
        rsync_opts  = "-rltDv --no-owner --no-group"
        source_path =  source =~ %r{/$} ? source : "#{source}/"
        dest        = File.join(workspace, File.basename(source))
        Dir.mkdir(dest) unless File.exist?(dest)
        dest_path   = Shellwords.escape("#{dest}/")

        result      = Rsync.run(source_path, dest_path, rsync_opts)
        raise "Fetch failure, method=openn_rsync: #{result.full_error}" unless result.success?

        return dest
      else
        raise "Invalid application #{application} specified."
    end
  end

  def verify path, application, method
    # TODO: make manifest & algorithm configurable? allow user to pass manifest path
    valid = true
    case "#{application}_#{method}"
    when 'bulwark_gitannex'
      # TODO: fill this in
    when 'openn_rsync'
      message_io = STDOUT
      Dir.chdir(path) do
        MANIFEST_MAP.each do |manifest, algorithm|
          if File.file?(manifest)
            LOGGER.info("Validating manifest #{File.join path, manifest}")
            valid &&= ManifestValidation::validate_manifest(manifest, algorithm, message_io: message_io)
          end
        end
      end
      LOGGER.info("Manifest validation result for #{path}: #{valid}")
    else
      raise "Invalid application #{application} specified."
    end

    return valid
  end

  def zip_package(manifest_data)
    zip_package = ZipFileGenerator.new(manifest_data[:fetched_source], manifest_data[:compressed_destination])
    zip_package.write
    true
  end

  def validate_transfer_data(todo_data)
    %i{ compressed_destination glacier_description glacier_vault }.each do |key|
      raise ArgumentError, "Required transfer value not present #{key.inspect}: " \
        "#{todo_data}" unless todo_data[key]
    end

    unless File.exist? todo_data[:compressed_destination]
      raise ArgumentError, "Cannot find :compressed_destination: " \
        "#{todo_data[:compressed_destination]}"
    end
  end

  def load_data(todo_file)
    begin
      YAML::load todo_file
    rescue
      raise ArgumentError, "Unable to read todo_file as YAML: #{todo_file.path}"
    end
  end

  def glacier_transfer(todo_data)
    glacier_secrets = SecretsManager.load_secrets('secrets/glacier.secret')
    SecretsManager.set(glacier_secrets)
    validate_transfer_data todo_data
    file_path           = todo_data[:compressed_destination]
    archive_description = todo_data[:glacier_description]
    vault_id            = todo_data[:glacier_vault]
    chunk_size          = ChunkSizer.calculate(File.stat(file_path).size)
    client              = Stronghold::Client.new(:multipart_chunk_size => chunk_size)
    backup_ids = client.create_backup vault_id, file_path, archive_description
    SecretsManager.unset(glacier_secrets)
    return backup_ids
  end

  def remove_zip_artifacts(todo_data)
    Dir.glob("#{todo_data[:workspace]}/*") do |path|
      git_annex_drop(path) if todo_data[:method] == 'gitannex' && File.extname(path) == '.git'
      FileUtils.rm_rf(path, :secure => true)
    end
  end

  def git_annex_drop(path)
    Dir.chdir(path) do
      `git annex drop --all --force`
    end
  end

  def update_fort_db(values_hash, vault_name)
    db = SecretsManager.load_secrets('secrets/db.secret')
    ActiveRecord::Base.establish_connection(
        :adapter => db['MYSQL_ADAPTER'],
        :host => db['MYSQL_HOST'],
        :username=> db['MYSQL_USER'],
        :password=> db['MYSQL_PASSWORD'],
        :database => db['MYSQL_DATABASE']
    )
    values_hash.each do |key, value|
      GlacierArchive.create(:description => value, :archive_id => key, :vault => vault_name)
    end
    SecretsManager.unset(db)
  end

  guardian = SecretsManager.load_secrets('secrets/guardian.secret')

  start :fetch_source

  task :fetch_source, on_fail: :FAIL, next_step: :verify_fetch do |todo_file|
    begin
      data = YAML.load todo_file
      LOGGER.info("Fetching archive for #{data[:todo_base]}...")
      # def fetch_source(source, workspace, application, method)
      fetched_source = fetch_source(data[:source], data[:workspace], data[:application], data[:method])

      # save the directory to zip to the todo file (used in next step)
      data[:fetched_source] = fetched_source
      todo_file.rewrite data.to_yaml
      true
    rescue Exception => ex
      LOGGER.fatal("ERROR: #{ex.message}")
      false
    end
  end

  task :verify_fetch, on_fail: :FAIL, next_step: :zip do |todo_file|
    begin
      data = YAML.load todo_file
      LOGGER.info("Verifying fetched data for #{data[:todo_base]}...")
      valid = verify(data[:fetched_source], data[:application], data[:method])
      if valid
        LOGGER.info("Fetched data verified :#{data[:fetched_source]}")
      else
        LOGGER.error("Verification failure: #{data[:fetched_source]}")
      end
      valid
    rescue Exception => ex
      LOGGER.fatal("ERROR: #{ex.message}")
      false
    end
  end

  task :zip, on_fail: :FAIL, next_step: :verify_zip do |todo_file|
    begin
      data = YAML.load todo_file
      LOGGER.info("Assembling archive for #{data[:todo_base]}...")
      zip_package(data)
      LOGGER.info('Archive assembled.')
      true
    rescue Exception => ex
      LOGGER.fatal("ERROR: #{ex.message}")
      false
    end
  end

  task :verify_zip, on_fail: :FAIL, next_step: :glacier do |todo_file|
    LOGGER.error("ERROR: intentionally failing test job")
    false
  end


  task :glacier, on_fail: :FAIL, next_step: :SUCCESS do |todo_file|
    begin
      data = load_data(todo_file)
      LOGGER.info("Initializing transfer to Glacier for #{data[:todo_base]}...")
      transfer_values  = glacier_transfer(data)
      LOGGER.info("Transfer complete.  Updating database with transfer information...")
      update_fort_db(transfer_values, data[:glacier_vault])
      LOGGER.info('Database updated.')
      LOGGER.info('Removing zip artifacts...')
      remove_zip_artifacts(data)
      LOGGER.info("Artifacts removed.  Fetch and transfer of #{data[:todo_base]} complete.")
      true
    rescue Exception => ex
      LOGGER.fatal("ERROR: #{ex.message}")
      false
    end
  end

end

LOGGER.info('Todo Runner initialized, starting run...')

TodoRunner.run(*ARGV)

LOGGER.info('Run complete.')
