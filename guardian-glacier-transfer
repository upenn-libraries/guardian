#!/usr/bin/env ruby

require 'active_record'
require 'find'
require 'logger'
require 'stronghold'
require 'todo_runner'
require 'yaml'
require 'zip'

# Copied from https://github.com/rubyzip/rubyzip

class ZipFileGenerator
  def initialize(input_dir, output_file)
    @input_dir = input_dir
    @output_file = output_file
  end

  def write
    entries = Dir.entries(@input_dir) - %w(. ..)
    ::Zip::File.open(@output_file, ::Zip::File::CREATE) do |zipfile|
      write_entries entries, '', zipfile
    end
  end

  private

  def write_entries(entries, path, zipfile)
    entries.each do |e|
      zipfile_path = path == '' ? e : File.join(path, e)
      disk_file_path = File.join(@input_dir, zipfile_path)
      puts "Deflating #{disk_file_path}"

      if File.directory? disk_file_path
        recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
      else
        put_into_archive(disk_file_path, zipfile, zipfile_path)
      end
    end
  end

  def recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
    zipfile.mkdir zipfile_path
    subdir = Dir.entries(disk_file_path) - %w(. ..)
    write_entries subdir, zipfile_path, zipfile
  end

  def put_into_archive(disk_file_path, zipfile, zipfile_path)
    zipfile.get_output_stream(zipfile_path) do |f|
      f.write(File.open(disk_file_path, 'rb').read)
    end
  end

end

class GlacierArchive < ActiveRecord::Base
  has_many :table_relationship
end

logger = Logger.new('| tee logger.log')
logger.level = Logger::INFO

TodoRunner.define do

  def load_secrets(secrets_path)
    secrets_hash = {}
    File.exist?("/run/secrets/#{secrets_path}") ? secrets_path = "/run/secrets/#{secrets_path}" : secrets_path
    File.readlines(secrets_path).each do |line|
      line.chomp!
      key, value = line.split('=',2)
      secrets_hash[key] = value
    end
    return secrets_hash
  end

  def fetch_source(source, workspace, application, method)
    case "#{application}_#{method}"
      when 'bulwark_gitannex'
        `git clone #{source} #{workspace}/#{File.basename(source)}`
        Dir.chdir("#{workspace}/#{File.basename(source)}") do
          `./.repoadmin/bin/init.sh`
          `git annex get .`
          `git annex unlock .`
        end
        return "#{workspace}/#{File.basename(source)}"
      when 'openn_rsync'
        #TODO: Fill this out
      else
        raise "Invalid application #{application} specified."
    end
  end

  def zip_package(manifest_data)
    directory_to_zip = fetch_source(manifest_data[:source], manifest_data[:workspace], manifest_data[:application], manifest_data[:method])
    zip_package = ZipFileGenerator.new(directory_to_zip, manifest_data[:compressed_destination])
    zip_package.write
    true
  end

  def validate_transfer_data(todo_data)
    %i{ compressed_destination glacier_description glacier_vault }.each do |key|
      raise ArgumentError, "Required transfer value not present #{key.inspect}: " \
        "#{todo_data}" unless todo_data[key]
    end

    unless File.exist? todo_data[:compressed_destination]
      raise ArgumentError, "Cannot find :compressed_destination: " \
        "#{todo_data[:compressed_destination]}"
    end
  end

  def load_data(todo_file)
    begin
      YAML::load todo_file
    rescue
      raise ArgumentError, "Unable to read todo_file as YAML: #{todo_file.path}"
    end
  end

  def glacier_transfer(todo_data)
    validate_transfer_data todo_data
    file_path           = todo_data[:compressed_destination]
    archive_description = todo_data[:glacier_description]
    vault_id            = todo_data[:glacier_vault]
    client              = Stronghold::Client.new
    client.create_backup vault_id, file_path, archive_description
  end

  def log_complete(values_hash)
    formatted_string = ''
    values_hash.each do |key, value|
      formatted_string << "#{key}#{LOG_FILE_SEPARATOR}#{value}\n"
    end
    File.open(LOG_FILE, 'a') { |file| file.write(formatted_string) }
    true
  end

  def remove_zip_artifacts(todo_data)
    Dir.glob("#{todo_data[:workspace]}/*") do |path|
      git_annex_drop(path) if todo_data[:method] == 'gitannex' && File.extname(path) == '.git'
      FileUtils.rm_rf(path, :secure => true)
    end
  end

  def git_annex_drop(path)
    Dir.chdir(path) do
      `git annex drop --all --force`
    end
  end

  def update_fort_db
    File.open(File.absolute_path(LOG_FILE)).each_line do |line|
      description, archive_id = line.split(LOG_FILE_SEPARATOR)
      GlacierArchive.create(:description => description, :archive_id => archive_id)
    end
  end

  LOG_FILE = ENV['LOG_FILE']

  LOG_FILE_SEPARATOR = ' | '

  DB = load_secrets('db.yml')

  ActiveRecord::Base.establish_connection(
      :adapter => DB['MYSQL_ADAPTER'],
      :host => DB['MYSQL_HOST'],
      :username=> DB['MYSQL_USERNAME'],
      :password=> DB['MYSQL_PASSWORD'],
      :database => DB['MYSQL_DATABASE']
  )

  start :zip

  task :zip, on_fail: :FAIL, next_step: :glacier do |todo_file|
    data = YAML.load todo_file
    logger.info("Fetching and assembling archive for #{data[:todo_base]}...")
    #zip_package(data)
    logger.info('Archive assembled.')
    true
  end

  task :glacier, on_fail: :FAIL, next_step: :SUCCESS do |todo_file|
    begin
      data = load_data(todo_file)
      logger.info("Initializing transfer to Glacier for #{data[:todo_base]}...")
      #transfer_values  = glacier_transfer(data)
      logger.info("Transfer complete.  Logging data to #{LOG_FILE}...")
      #log_complete(transfer_values)
      logger.info('Logging complete.  Removing zip artifacts...')
      #remove_zip_artifacts(data)
      logger.info("Artifacts removed.  Fetch and transfer of #{data[:todo_base]} complete.")
      true
    rescue ArgumentError => ex
      puts "ERROR #{ex.message}"
      false
    end
    true
  end

  after :all do
    logger.info('Updating database with transfer information...')
    update_fort_db
    logger.info('Database updated.')
  end

end

logger.info('Todo Runner initialized, starting run...')

TodoRunner.run(*ARGV)

logger.info('Run complete.')