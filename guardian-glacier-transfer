#!/usr/bin/env ruby

require 'active_record'
require 'find'
require 'logger'
require 'stronghold'
require 'todo_runner'
require 'yaml'
require 'zip'
require 'rsync'
require 'shellwords'

require_relative('lib/secrets_manager')
require_relative('lib/chunk_sizer')

##
# Monkey patching Rsync::Result to get useful error messages.
class Rsync::Result
  def raw
    @raw
  end

  def full_error
    return if self.success?
    raw.split($/).grep(/^rsync( error)?:/).join $/
  end
end

# Copied from https://github.com/rubyzip/rubyzip

class ZipFileGenerator
  def initialize(input_dir, output_file)
    @input_dir = input_dir
    @output_file = output_file
  end

  def write
    entries = Dir.entries(@input_dir) - %w(. ..)
    ::Zip::File.open(@output_file, ::Zip::File::CREATE) do |zipfile|
      write_entries entries, '', zipfile
    end
  end

  private

  def write_entries(entries, path, zipfile)
    entries.each do |e|
      zipfile_path = path == '' ? e : File.join(path, e)
      disk_file_path = File.join(@input_dir, zipfile_path)
      puts "Deflating #{disk_file_path}"

      if File.directory? disk_file_path
        recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
      else
        put_into_archive(disk_file_path, zipfile, zipfile_path)
      end
    end
  end

  def recursively_deflate_directory(disk_file_path, zipfile, zipfile_path)
    zipfile.mkdir zipfile_path
    subdir = Dir.entries(disk_file_path) - %w(. ..)
    write_entries subdir, zipfile_path, zipfile
  end

  def put_into_archive(disk_file_path, zipfile, zipfile_path)
    zipfile.get_output_stream(zipfile_path) do |f|
      f.write(File.open(disk_file_path, 'rb').read)
    end
  end

end

class GlacierArchive < ActiveRecord::Base
  has_many :table_relationship
end

logger = Logger.new(STDOUT)
logger.level = Logger::INFO

TodoRunner.define do

  def fetch_source(source, workspace, application, method)
    case "#{application}_#{method}"
      when 'bulwark_gitannex'
        bg_secrets = SecretsManager.load_secrets('secrets/bulwark_gitannex.secret')
        SecretsManager.set(bg_secrets)
        `git clone #{source} #{workspace}/#{File.basename(source)}`
        Dir.chdir("#{workspace}/#{File.basename(source)}") do
          `./.repoadmin/bin/init.sh`
          `git annex get .`
          `git annex unlock .`
        end
        SecretsManager.unset(bg_secrets)
        return "#{workspace}/#{File.basename(source)}"
      when 'openn_rsync'
        rsync_opts  = "-rltDv --no-owner --no-group"
        source_path = Shellwords.escape(source)
        dest        = File.join(workspace, File.basename(source))
        dest_path   = Shellwords.escape(dest)

        result      = Rsync.run(source_path, dest_path, rsync_opts)
        raise "Fetch failure, method=openn_rsync: #{result.full_error}" unless result.success?

        return dest
      else
        raise "Invalid application #{application} specified."
    end
  end

  def zip_package(manifest_data)
    directory_to_zip = fetch_source(manifest_data[:source], manifest_data[:workspace], manifest_data[:application], manifest_data[:method])
    zip_package = ZipFileGenerator.new(directory_to_zip, manifest_data[:compressed_destination])
    zip_package.write
    true
  end

  def validate_transfer_data(todo_data)
    %i{ compressed_destination glacier_description glacier_vault }.each do |key|
      raise ArgumentError, "Required transfer value not present #{key.inspect}: " \
        "#{todo_data}" unless todo_data[key]
    end

    unless File.exist? todo_data[:compressed_destination]
      raise ArgumentError, "Cannot find :compressed_destination: " \
        "#{todo_data[:compressed_destination]}"
    end
  end

  def load_data(todo_file)
    begin
      YAML::load todo_file
    rescue
      raise ArgumentError, "Unable to read todo_file as YAML: #{todo_file.path}"
    end
  end

  def glacier_transfer(todo_data)
    glacier_secrets = SecretsManager.load_secrets('secrets/glacier.secret')
    SecretsManager.set(glacier_secrets)
    validate_transfer_data todo_data
    file_path           = todo_data[:compressed_destination]
    archive_description = todo_data[:glacier_description]
    vault_id            = todo_data[:glacier_vault]
    chunk_size          = ChunkSizer.calculate(File.stat(file_path).size)
    client              = Stronghold::Client.new(:multipart_chunk_size => chunk_size)
    backup_ids = client.create_backup vault_id, file_path, archive_description
    SecretsManager.unset(glacier_secrets)
    return backup_ids
  end

  def remove_zip_artifacts(todo_data)
    Dir.glob("#{todo_data[:workspace]}/*") do |path|
      git_annex_drop(path) if todo_data[:method] == 'gitannex' && File.extname(path) == '.git'
      FileUtils.rm_rf(path, :secure => true)
    end
  end

  def git_annex_drop(path)
    Dir.chdir(path) do
      `git annex drop --all --force`
    end
  end

  def update_fort_db(values_hash, vault_name)
    db = SecretsManager.load_secrets('secrets/db.secret')
    ActiveRecord::Base.establish_connection(
        :adapter => db['MYSQL_ADAPTER'],
        :host => db['MYSQL_HOST'],
        :username=> db['MYSQL_USER'],
        :password=> db['MYSQL_PASSWORD'],
        :database => db['MYSQL_DATABASE']
    )
    values_hash.each do |key, value|
      GlacierArchive.create(:description => value, :archive_id => key, :vault => vault_name)
    end
    SecretsManager.unset(db)
  end

  guardian = SecretsManager.load_secrets('secrets/guardian.secret')

  start :zip

  task :zip, on_fail: :FAIL, next_step: :glacier do |todo_file|
    begin
      data = YAML.load todo_file
      logger.info("Fetching and assembling archive for #{data[:todo_base]}...")
      zip_package(data)
      logger.info('Archive assembled.')
      true
    rescue Exception => ex
      logger.fatal("ERROR: #{ex.message}")
      false
    end
  end

  task :glacier, on_fail: :FAIL, next_step: :SUCCESS do |todo_file|
    begin
      data = load_data(todo_file)
      logger.info("Initializing transfer to Glacier for #{data[:todo_base]}...")
      transfer_values  = glacier_transfer(data)
      logger.info("Transfer complete.  Updating database with transfer information...")
      update_fort_db(transfer_values, data[:glacier_vault])
      logger.info('Database updated.')
      logger.info('Removing zip artifacts...')
      remove_zip_artifacts(data)
      logger.info("Artifacts removed.  Fetch and transfer of #{data[:todo_base]} complete.")
      true
    rescue Exception => ex
      logger.fatal("ERROR: #{ex.message}")
      false
    end
  end

end

logger.info('Todo Runner initialized, starting run...')

TodoRunner.run(*ARGV)

logger.info('Run complete.')
